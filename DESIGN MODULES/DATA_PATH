module data_path (
    input  wire        clk,
    input  wire        reset,

    // --------- OBSERVABILITY PORTS ----------
    output wire [31:0] pc,// from pc_gen module
    output wire [31:0] instr,// from ins_mem

    output wire [4:0]  rs1_addr, 
    output wire [4:0]  rs2_addr,
    output wire [4:0]  rd_addr,

    output wire [31:0] rs1_val,
    output wire [31:0] rs2_val,
    output wire [31:0] rd_val,

    output wire [31:0] alu_result,
    output wire        reg_write,
    output wire        we,
    output wire [31:0] imm_i,
    output wire [31:0] imm_s,
    output wire [31:0] imm_b,
    output wire [31:0] imm_u,
    output wire [31:0] imm_j
    
);

    // -------------------------
    // PC logic (word addressable)
    // -------------------------
    // ---------------- Comparisons ----------------

wire eq;
wire lt_signed;
wire lt_unsigned;
wire lui_auipc;
wire jal;
wire jalr;



assign eq          = (rs1_val == rs2_val);
assign lt_signed   = ($signed(rs1_val) < $signed(rs2_val));
assign lt_unsigned = (rs1_val < rs2_val);



// ---------------- Branch Decision ----------------

reg branch_taken;
 wire beq_n;
wire blt_s_un;
wire bgt_e_s_un;

  // -------------------------
    // Decode fields
    // -------------------------
    wire [2:0] funct3   = instr[14:12];
    wire       funct7_5 = instr[30];
    wire [6:0] opcode   = instr[6:0];
   wire [2:0] imm_sel;

always @(*) begin 
    branch_taken = 1'b0;

    if (opcode == 7'b1100011) begin

        // BEQ
        if (funct3 == 3'b000)
            branch_taken = eq;

        // BNE
        else if (funct3 == 3'b001)
            branch_taken = !eq;

        // BLT
        else if (funct3 == 3'b100)
            branch_taken = lt_signed;

        // BGE
        else if (funct3 == 3'b101)
            branch_taken = !lt_signed;

        // BLTU
        else if (funct3 == 3'b110)
            branch_taken = lt_unsigned;

        // BGEU
        else if (funct3 == 3'b111)
            branch_taken = !lt_unsigned;
    end
end











// ---------------- PC Logic ----------------

wire [31:0] pc_plus_1;
wire [31:0] branch_offset_word;
wire [31:0] pc_branch;
wire [31:0] pc_next;

assign pc_plus_1         = pc + 32'd1;
assign branch_offset_word = $signed(imm_b) >>> 2;
   // convert byte offset to word offset
assign pc_branch         = pc + branch_offset_word;

assign pc_next =
    jalr         ? jalr_target :
    jal          ? pc + jump_offset_word :
    branch_taken ? pc_branch :
                   pc_plus_1;



    pc_gen PC (
        .clk     (clk),
        .reset   (reset),
        .pc_en   (1'b1),
        .pc_next (pc_next),
        .pc      (pc)
    );

    // -------------------------
    // Instruction Memory
    // -------------------------
    ins_mem IMEM (
        .pc    (pc),
        .instr (instr)
    );

    // -------------------------
    // Instruction fields
    // -------------------------
    assign rs1_addr = instr[19:15];
    assign rs2_addr = instr[24:20];
    assign rd_addr  = instr[11:7];

    // -------------------------
    // Control Signals
    // -------------------------
    wire alu_src;
    wire mem_read;
    wire mem_write;
    wire wb_sel;

    wire [1:0] load_size;
    wire       load_unsigned;
    wire [1:0] store_size;

    assign we = reg_write;

    // -------------------------
    // Writeback MUX
    // -------------------------
    wire [31:0] mem_read_data;
    assign rd_val =
    (jal || jalr) ? pc_plus_1 :
    wb_sel        ? mem_read_data :
                    alu_result;


    // -------------------------
    // Immediate Generator
    // -------------------------
    imm_gen IMM_GEN (
        .ins (instr),
        .imm_i    (imm_i),
        .imm_s    (imm_s),
        .imm_b    (imm_b),
        .imm_u    (imm_u),
        .imm_j    (imm_j)
    );

    // -------------------------
    // ALU input mux
    // -------------------------
    wire [31:0] alu_b;
    wire [31:0] alu_a;

   
    wire [31:0] imm;
    assign alu_b = (alu_src) ? imm : rs2_val;



  



assign imm =
    (imm_sel == 3'b000) ? imm_i :
    (imm_sel == 3'b001) ? imm_s :
    (imm_sel == 3'b010) ? imm_b :
    (imm_sel == 3'b011) ? imm_u :
                          imm_j;
    
    
    
    
    
    
    

    // -------------------------
    // Control Unit
    // -------------------------
  control_unit CU (
    .opcode        (opcode),
    .funct3        (funct3),

    .reg_write     (reg_write),
    .alu_src       (alu_src),
    .mem_read      (mem_read),
    .mem_write     (mem_write),
    .wb_sel        (wb_sel),

    .load_size     (load_size),
    .load_unsigned (load_unsigned),
    .store_size    (store_size),

    .imm_sel       (imm_sel),

    // ---- B-Type Control Signals ----
    .beq_n         (beq_n),
    .blt_s_un      (blt_s_un),
    .bgt_e_s_un    (bgt_e_s_un),
    .lui_auipc      (lui_auipc),
    .jal  (jal),
.jalr (jalr)

);


    // -------------------------
    // Register File
    // -------------------------
    register_file RF (
        .clk  (clk),
        .we   (we),
        .rs1  (rs1_addr),
        .rs2  (rs2_addr),
        .rd   (rd_addr),
        .wd   (rd_val),
        .rd1  (rs1_val),
        .rd2  (rs2_val)
    );

    // -------------------------
    // ALU Control
    // -------------------------
    wire [3:0] alu_ctrl;

    alu_control ALU_CTRL (
        .opcode   (opcode),
        .funct3   (funct3),
        .funct7_5 (funct7_5),
        .alu_ctrl (alu_ctrl)
    );

    // -------------------------
    // ALU
    // -------------------------
    // U-Type ALU A selection
assign alu_a = (opcode == 7'b0110111) ? 32'b0 :   // LUI
               (opcode == 7'b0010111) ? pc       : // AUIPC
                                         rs1_val;  // All others

alu ALU (
    .a        (alu_a),
    .b        (alu_b),
    .alu_ctrl (alu_ctrl),
    .result   (alu_result)
);


    // -------------------------
    // Data Memory 
    // -------------------------
    data_mem DMEM (
    .clk           (clk),
    .mem_write     (mem_write),
    .mem_read      (mem_read),
    .load_size     (load_size),
    .load_unsigned (load_unsigned),
    .store_size    (store_size),   // ADD THIS
    .addr          (alu_result),
    .write_data    (rs2_val),
    .read_data     (mem_read_data)
);

wire [31:0] jump_offset_word;
assign jump_offset_word = $signed(imm_j) >>> 2;
wire [31:0] jalr_target;
assign jalr_target = (rs1_val + imm_i) >> 2;


endmodule
