module ins_mem (
    input  wire [31:0] pc,        // word address
    output wire [31:0] instr
);

    reg [31:0] mem [0:255];

    initial begin
    // -------------------------------------------------
    // RISC-V RV32I : R-type instruction program
    // -------------------------------------------------

    // x1 = 5, x2 = 5  (assume preloaded via testbench)

    // add x3, x1, x2   -> x3 = 10
    mem[0] = 32'b00000000001000001000000110110011;

    // sub x4, x3, x2   -> x4 = 10
    mem[1] = 32'b01000000001000011000001000110011;

    // and x5, x3, x4
    mem[2] = 32'b00000000010000011111001010110011;

    // or x6, x3, x4
    mem[3] = 32'b00000000010000011110001100110011;

    // xor x7, x3, x4
    mem[4] = 32'b00000000010000011100001110110011;

    // slt x8, x2, x1
    mem[5] = 32'b00000000001100100010010000110011;

    // add x9, x8, x3
    mem[6] = 32'b00000000001101000000010010110011;

    // nop
    mem[7] = 32'b00000000000000000000000000110011;

    // sll x5, x3, x2
    mem[8]  = 32'b0000000_00010_00011_001_00101_0110011;

    // srl x5, x3, x2
    mem[9]  = 32'b0000000_00010_00011_101_00101_0110011;

    // sra x5, x3, x2
    mem[10] = 32'b0100000_00010_00011_101_00101_0110011;

    // sltu x5, x3, x2
    mem[11] = 32'b0000000_00010_00011_011_00101_0110011;

    // -------------------------------------------------
    // RISC-V RV32I : I-type instruction program
    // -------------------------------------------------

    // addi x10, x3, 5   -> 15 + 5 = 20
    mem[12] = 32'b000000000101_00011_000_01010_0010011;

    // andi x11, x3, 6   -> 15 & 6 = 6
    mem[13] = 32'b000000000110_00011_111_01011_0010011;

    // ori x12, x3, 1    -> 15 | 1 = 15
    mem[14] = 32'b000000000001_00011_110_01100_0010011;

    // xori x13, x3, 3   -> 15 ^ 3 = 12
    mem[15] = 32'b000000000011_00011_100_01101_0010011;

    // slti x14, x4, 15  -> (10 < 15) = 1
    mem[16] = 32'b000000001111_00100_010_01110_0010011;

    // slli x15, x3, 2   -> 15 << 2 = 60
    mem[17] = 32'b0000000_00010_00011_001_01111_0010011;

    // srli x16, x3, 1   -> 15 >> 1 = 7
    mem[18] = 32'b0000000_00001_00011_101_10000_0010011;

    // srai x17, x3, 1   -> arithmetic shift
    mem[19] = 32'b0100000_00001_00011_101_10001_0010011;
    //lw x5,0(x1) Load word from mem[x1 + 0] into x5 ie ...if x1 = 10 then word will be from mem[10,11,12,13]
    mem[20] = 32'b000000000000_00001_010_00101_0000011;
    // lw x6, 4(x1) Load word from mem[x1 + 4] into x6
    mem[21] = 32'b000000000100_00001_010_00110_0000011;
    // lb x7, 0(x1) Load signed byte from mem[x1]
    mem[22] = 32'b000000000000_00001_000_00111_0000011;
    // lb x8, 1(x1) Load byte from next address
    mem[23] = 32'b000000000001_00001_000_01000_0000011;
    // lh x9, 0(x1)   Load signed halfword
    mem[24] = 32'b000000000000_00001_001_01001_0000011;

    // lh x10, 2(x1)  Load signed halfword from offset 2
    mem[25] = 32'b000000000010_00001_001_01010_0000011;

    // lbu x11, 0(x1) Load unsigned byte
    mem[26] = 32'b000000000000_00001_100_01011_0000011;

    // lbu x12, 3(x1) Load unsigned byte
    mem[27] = 32'b000000000011_00001_100_01100_0000011;

    // lhu x13, 0(x1) Load unsigned halfword
    mem[28] = 32'b000000000000_00001_101_01101_0000011;

    // lhu x14, 2(x1) Load unsigned halfword
    mem[29] = 32'b000000000010_00001_101_01110_0000011;
    // sb x2, 0(x1) Store lowest byte of x2 into mem[x1 + 0]
    mem[30] = 32'b0000000_00010_00001_000_00000_0100011;

    // sb x2, 3(x1) Store byte into mem[x1 + 3]
    mem[31] = 32'b0000000_00010_00001_000_00011_0100011;
    // sh x2, 0(x1) Store lower 16 bits of x2 into mem[x1 + 0]
    mem[32] = 32'b0000000_00010_00001_001_00000_0100011;

    // sh x2, 4(x1) Store halfword into mem[x1 + 4]
    mem[33] = 32'b0000000_00010_00001_001_00100_0100011;
    // sw x2, 0(x1) Store 32-bit word of x2 into mem[x1 + 0]
    mem[34] = 32'b0000000_00010_00001_010_00000_0100011;

    // sw x2, 8(x1) Store word into mem[x1 + 8]
    mem[35] = 32'b0000000_00010_00001_010_01000_0100011;
    // sw x2, -4(x1) Store word at mem[x1 - 4]
    mem[36] = 32'b1111111_00010_00001_010_11100_0100011;
    // load back mem[6] to register
    mem[37] = 32'b111111111100_00001_010_01011_0000011;
    // BEQ x1, x2, +2 instructions
    // If (x1 == x2)
    //     PC = PC + 2   (skip next 2 instructions)
    // Else
    //     PC = PC + 1   (normal sequential execution)
// -------------------------------------------------
// CORRECT B-TYPE (+2 words = +8 bytes)
// rs1 = x1, rs2 = x2
// -------------------------------------------------

// BEQ x1, x2, +2
mem[38] = 32'b00000000001000001000100001100011;  // 0x00208863

// add (should be skipped if branch taken)
mem[39] = 32'b00000000001000001000000110110011;

// sub (should be skipped if branch taken)
mem[40] = 32'b01000000001000011000001000110011;

// and
mem[41] = 32'b00000000010000011111001010110011;


// BNE x1, x2, +2
mem[42] = 32'b00000000001000001001100001100011;  // 0x00209863

// BLT x1, x2, +2
mem[43] = 32'b00000000001000001100100001100011;  // 0x0020C863

// BGE x1, x2, +2
mem[44] = 32'b00000000001000001101100001100011;  // 0x0020D863

// BLTU x1, x2, +2
mem[45] = 32'b00000000001000001110100001100011;  // 0x0020E863

// BGEU x1, x2, +2
mem[46] = 32'b00000000001000001111100001100011;  // 0x0020F863
//LUI x5, 0x12345
mem[47] = 32'h123452B7;
//AUIPC x6, 0x12345
mem[48] = 32'h12345317;
//LUI x5, 0x12345
mem[49] = 32'h123452B7;
//JAL x1, 8
mem[50] = 32'h008000EF;
//JAL x5, 16
mem[51] = 32'h010002EF;
//JAL x0, -4
mem[52] = 32'hFFDFF06F;
//JALR x0, x1, 0
mem[53] = 32'h00008067;

//





    end

    assign instr = mem[pc];

endmodule
